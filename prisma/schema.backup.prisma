generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  password      String
  role          String    @default("admin")
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Client {
  id               String      @id @default(cuid())
  firstName        String
  lastName         String
  email            String      @unique
  phone            String?
  dateOfBirth      DateTime?
  gender           String?     // "male" or "female"
  isTruckDriver    Boolean     @default(true)
  dotNumber        String?
  cdlNumber        String?
  
  // Health Information
  healthGoals      Json?
  medications      Json?
  conditions       Json?
  allergies        Json?
  
  // Status
  status           String      @default("active")
  lastVisit        DateTime?
  
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  
  documents        Document[]
  assessments      Assessment[]
  protocols        Protocol[]
  notes            Note[]
  statuses         ClientStatus[]
  medicalDocuments MedicalDocument[]
}

model Document {
  id               String      @id @default(cuid())
  clientId         String
  client           Client      @relation(fields: [clientId], references: [id])
  
  fileName         String
  fileType         String
  fileSize         Int
  fileUrl          String
  
  documentType     String      // lab_report, assessment, other
  labType          String?     // nutriq, labcorp, quest, dutch, kbmo
  
  // Processing Status
  status           String      @default("uploaded") // uploaded, processing, completed, failed
  processingError  String?
  
  // Extracted Data
  extractedText    String?     @db.Text
  extractedData    Json?       // Structured lab values
  ocrConfidence    Float?
  
  // AI Analysis
  aiAnalysis       Json?
  analysisDate     DateTime?
  
  uploadedAt       DateTime    @default(now())
  processedAt      DateTime?
  
  @@index([clientId])
  @@index([status])
}

model Assessment {
  id               String      @id @default(cuid())
  clientId         String
  client           Client      @relation(fields: [clientId], references: [id])
  
  assessmentType   String      @default("comprehensive") // comprehensive, focused, follow-up
  status           String      @default("in_progress") // in_progress, completed
  
  responses        Json        // All 150 question responses
  symptomBurden    Json?       // Calculated scores by system
  rootCauses       Json?       // Identified root causes
  
  aiAnalysis       Json?
  recommendations  Json?
  
  startedAt        DateTime    @default(now())
  completedAt      DateTime?
  
  protocols        Protocol[]
  
  @@index([clientId])
  @@index([status])
}

model Protocol {
  id               String      @id @default(cuid())
  clientId         String
  client           Client      @relation(fields: [clientId], references: [id])
  
  assessmentId     String?
  assessment       Assessment? @relation(fields: [assessmentId], references: [id])
  
  protocolName     String
  status           String      @default("active") // active, completed, paused
  
  supplements      Json        // Supplement recommendations
  dietary          Json        // Dietary recommendations
  lifestyle        Json        // Lifestyle recommendations
  
  timeline         Json        // Implementation timeline
  metrics          Json?       // Success metrics
  
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  completedAt      DateTime?
  
  @@index([clientId])
  @@index([status])
}

model Note {
  id            String    @id @default(cuid())
  clientId      String
  client        Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  noteType      NoteType
  title         String?
  
  // Interview Notes structured fields
  chiefComplaints    String?   @db.Text
  healthHistory      String?   @db.Text
  currentMedications String?   @db.Text
  goals             String?   @db.Text
  
  // Coaching Call structured fields
  protocolAdjustments String?   @db.Text
  complianceNotes     String?   @db.Text
  progressMetrics     String?   @db.Text
  nextSteps          String?   @db.Text
  
  // Common fields
  generalNotes       String?   @db.Text
  isImportant       Boolean   @default(false)
  followUpNeeded    Boolean   @default(false)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([clientId, noteType])
  @@index([createdAt])
}

enum NoteType {
  INTERVIEW
  COACHING
}

model ClientStatus {
  id          String         @id @default(cuid())
  clientId    String
  client      Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  status      StatusType
  notes       String?        @db.Text
  createdAt   DateTime       @default(now())
  createdBy   String?        // Track who made the status change
  
  @@index([clientId, createdAt])
  @@index([status])
}

enum StatusType {
  SIGNED_UP
  INITIAL_INTERVIEW_COMPLETED
  ASSESSMENT_COMPLETED
  DOCS_UPLOADED
  SCHEDULED
  ONGOING
  ARCHIVED
}

// ====== MEDICAL DOCUMENT PROCESSING SYSTEM ======
// New models for advanced medical document processing (separate from existing Document system)

model MedicalDocument {
  id               String               @id @default(cuid())
  clientId         String?              @map("client_id")
  documentType     String               @map("document_type")
  originalFileName String               @map("original_file_name")
  s3Url           String?              @map("s3_url")
  s3Key           String?              @map("s3_key")
  uploadDate      DateTime             @default(now()) @map("upload_date")
  status          MedicalDocStatus     @default(PENDING)
  ocrText         String?              @db.Text @map("ocr_text")
  ocrConfidence   Float?               @map("ocr_confidence")
  processedAt     DateTime?            @map("processed_at")
  errorMessage    String?              @map("error_message")
  metadata        Json?
  
  labValues       MedicalLabValue[]
  analysis        MedicalDocAnalysis?
  
  // Links to your existing Client model
  client          Client?              @relation(fields: [clientId], references: [id])
  
  @@index([clientId, uploadDate])
  @@index([status])
  @@map("medical_documents")
}

model MedicalLabValue {
  id                String          @id @default(cuid())
  documentId        String          @map("document_id")
  testName          String          @map("test_name")
  standardName      String?         @map("standard_name") // LOINC code or standard mapping
  value             Float?
  valueText         String?         @map("value_text") // For non-numeric results
  unit              String?
  referenceMin      Float?          @map("reference_min")
  referenceMax      Float?          @map("reference_max")
  functionalMin     Float?          @map("functional_min") // IFM/Kresser ranges
  functionalMax     Float?          @map("functional_max")
  optimalMin        Float?          @map("optimal_min")
  optimalMax        Float?          @map("optimal_max")
  flag              String?         // normal, high, low, critical
  collectionDate    DateTime?       @map("collection_date")
  labSource         String?         @map("lab_source") // LabCorp, Quest, etc.
  confidence        Float?          @default(1.0)
  
  document          MedicalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([documentId])
  @@index([testName])
  @@index([standardName])
  @@map("medical_lab_values")
}

model MedicalDocAnalysis {
  id               String          @id @default(cuid())
  documentId       String          @unique @map("document_id")
  patterns         Json            // Detected patterns with confidence scores
  rootCauses       Json?           @map("root_causes")
  criticalValues   Json?           @map("critical_values")
  functionalStatus Json?           @map("functional_status")
  crossReferences  Json?           @map("cross_references")
  trends           Json?
  recommendations  Json?
  createdAt        DateTime        @default(now()) @map("created_at")
  
  document         MedicalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@map("medical_document_analyses")
}

model MedicalProcessingQueue {
  id            String              @id @default(cuid())
  documentId    String              @map("document_id")
  jobType       String              @map("job_type") // ocr, extraction, analysis
  priority      Int                 @default(0)
  status        MedicalJobStatus    @default(QUEUED)
  attempts      Int                 @default(0)
  maxAttempts   Int                 @default(3) @map("max_attempts")
  errorMessage  String?             @map("error_message")
  startedAt     DateTime?           @map("started_at")
  completedAt   DateTime?           @map("completed_at")
  createdAt     DateTime            @default(now()) @map("created_at")
  
  @@index([status, priority])
  @@map("medical_processing_queue")
}

// New enums with unique names to avoid any conflicts
enum MedicalDocStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REQUIRES_REVIEW
}

enum MedicalJobStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  RETRY
}