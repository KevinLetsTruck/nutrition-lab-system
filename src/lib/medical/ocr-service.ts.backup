import Tesseract from "tesseract.js";
import { createWorker } from "tesseract.js";
// import mammoth from 'mammoth' // Reserved for future Word document support
import { prisma } from "@/lib/db/prisma";
import { medicalDocStorage } from "./s3-storage";
import { labValueExtractor } from "./lab-extractor";
import { cloudinaryService } from "@/lib/storage/cloudinary-service";

interface OCRResult {
  text: string;
  confidence: number;
  processingTime: number;
  method: "tesseract" | "pdf-text" | "hybrid";
  pageCount?: number;
  wordCount: number;
}

interface DocumentProcessingResult {
  ocrResult: OCRResult;
  documentType: string;
  labSource?: string;
  extractedData?: any;
}

export class MedicalOCRService {
  private tesseractWorker: Tesseract.Worker | null = null;

  async initializeTesseract(): Promise<void> {
    if (this.tesseractWorker) return;

    console.log("üîß Initializing Tesseract OCR worker...");

    try {
      // Use simpler initialization without custom worker path
      this.tesseractWorker = await createWorker("eng", 1, {
        logger: (m) => {
          if (m.status === "recognizing text") {
            console.log(`üìñ OCR Progress: ${Math.round(m.progress * 100)}%`);
          }
        },
      });

      // Optimize for medical documents
      await this.tesseractWorker.setParameters({
        tessedit_char_whitelist:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,()[]/-+= :;%<>",
        tessedit_pageseg_mode: Tesseract.PSM.AUTO,
        preserve_interword_spaces: "1",
      });

      console.log("‚úÖ Tesseract worker initialized successfully");
    } catch (error: any) {
      console.error("‚ùå Failed to initialize Tesseract worker:", error);
      // Try minimal fallback initialization
      console.log("üîÑ Trying minimal Tesseract initialization...");
      try {
        this.tesseractWorker = await createWorker("eng");
        console.log(
          "‚úÖ Tesseract worker initialized with minimal configuration"
        );
      } catch (fallbackError: any) {
        console.error(
          "‚ùå All Tesseract initialization methods failed:",
          fallbackError
        );
        throw new Error(
          `Tesseract initialization failed: ${fallbackError.message}`
        );
      }
    }
  }

  async processDocument(documentId: string): Promise<DocumentProcessingResult> {
    const startTime = Date.now();
    console.log(`üîç Starting OCR processing for document: ${documentId}`);

    try {
      // Update status to processing with timeout protection
      await prisma.medicalDocument.update({
        where: { id: documentId },
        data: { status: "PROCESSING" },
      });

      // Set overall timeout for the entire processing (5 minutes max)
      const processingPromise = this.performDocumentProcessing(
        documentId,
        startTime
      );
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(
          () =>
            reject(new Error("Document processing timeout after 5 minutes")),
          300000
        )
      );

      return (await Promise.race([
        processingPromise,
        timeoutPromise,
      ])) as DocumentProcessingResult;
    } catch (error: any) {
      console.error(
        `‚ùå OCR processing error for document ${documentId}:`,
        error
      );

      // CRITICAL: Always update document status even if processing fails
      try {
        await prisma.medicalDocument.update({
          where: { id: documentId },
          data: {
            status: "FAILED",
            errorMessage: error.message.substring(0, 1000), // Limit error message length
            processedAt: new Date(),
          },
        });

        // Also update processing queue
        await prisma.medicalProcessingQueue.updateMany({
          where: { documentId: documentId },
          data: {
            status: "FAILED",
            completedAt: new Date(),
            errorMessage: error.message.substring(0, 1000),
          },
        });

        console.log(`‚úÖ Document ${documentId} marked as FAILED in database`);
      } catch (dbError: any) {
        console.error(`‚ùå Failed to update document status:`, dbError);
      }

      throw error;
    }
  }

  private async performDocumentProcessing(
    documentId: string,
    startTime: number
  ): Promise<DocumentProcessingResult> {
    try {
      // Get document details
      const document = await prisma.medicalDocument.findUnique({
        where: { id: documentId },
      });

      if (!document) {
        throw new Error("Document not found");
      }

      console.log(
        `üìÑ Processing: ${document.originalFileName} (${document.documentType})`
      );

      // Get signed URL for processing
      const fileUrl = await medicalDocStorage.getSignedUrl(document.s3Key!);

      // Determine processing method based on file type
      const mimeType = document.metadata?.mimeType as string;
      let ocrResult: OCRResult;

      if (mimeType === "application/pdf") {
        console.log("üìë Processing PDF document with Cloudinary conversion...");
        ocrResult = await this.processPDFWithCloudinary(fileUrl);
      } else if (mimeType?.startsWith("image/")) {
        ocrResult = await this.processImage(fileUrl);
      } else {
        throw new Error(`Unsupported file type: ${mimeType}`);
      }

      // Classify document based on extracted text
      const { documentType, labSource, extractedData } =
        await this.classifyDocument(ocrResult.text, document.originalFileName);

      // Update database with results
      await prisma.medicalDocument.update({
        where: { id: documentId },
        data: {
          ocrText: ocrResult.text,
          ocrConfidence: ocrResult.confidence,
          documentType: documentType,
          status: "COMPLETED",
          processedAt: new Date(),
          metadata: {
            ...document.metadata,
            ocrMethod: ocrResult.method,
            processingTime: ocrResult.processingTime,
            wordCount: ocrResult.wordCount,
            pageCount: ocrResult.pageCount,
            labSource,
            classificationConfidence: extractedData?.confidence || 0,
          },
        },
      });

      const totalTime = Date.now() - startTime;
      console.log(`‚úÖ OCR processing complete: ${documentId} (${totalTime}ms)`);

      // Automatically extract lab values from OCR text
      if (ocrResult.text && ocrResult.text.length > 50) {
        console.log("üß™ Triggering lab value extraction...");
        try {
          const labResult = await labValueExtractor.extractLabValues(
            documentId,
            ocrResult.text
          );
          console.log(
            `üéØ Lab extraction complete: ${labResult.totalFound} values extracted`
          );

          // Update document metadata with lab extraction results
          await prisma.medicalDocument.update({
            where: { id: documentId },
            data: {
              metadata: {
                ...document.metadata,
                ocrMethod: ocrResult.method,
                processingTime: ocrResult.processingTime,
                wordCount: ocrResult.wordCount,
                pageCount: ocrResult.pageCount,
                labSource,
                classificationConfidence: extractedData?.confidence || 0,
                labExtractionComplete: true,
                labValuesFound: labResult.totalFound,
                highConfidenceLabValues: labResult.highConfidenceCount,
                labExtractionTime: labResult.processingTime,
              },
            },
          });
        } catch (labError) {
          console.error("‚ö†Ô∏è Lab extraction failed:", labError);
          // Don't fail the OCR process if lab extraction fails
        }
      }

      return {
        ocrResult,
        documentType,
        labSource,
        extractedData,
      };
    } catch (error) {
      console.error("‚ùå OCR processing error:", error);

      await prisma.medicalDocument.update({
        where: { id: documentId },
        data: {
          status: "FAILED",
          errorMessage:
            error instanceof Error ? error.message : "OCR processing failed",
        },
      });

      throw error;
    }
  }

  // PDF processing temporarily provides guidance instead of processing
  // This ensures users get the best possible results for lab value extraction

  private async processImage(imageUrl: string): Promise<OCRResult> {
    console.log("üñºÔ∏è Processing image document...");
    const startTime = Date.now();

    try {
      await this.initializeTesseract();

      const result = await this.tesseractWorker!.recognize(imageUrl);

      return {
        text: result.data.text,
        confidence: result.data.confidence / 100, // Normalize to 0-1
        processingTime: Date.now() - startTime,
        method: "tesseract",
        pageCount: 1,
        wordCount: result.data.text.split(/\s+/).length,
      };
    } catch (error) {
      console.error("‚ùå Image OCR processing failed:", error);
      throw new Error(
        `Failed to process image: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  private async processPDFWithCloudinary(pdfUrl: string): Promise<OCRResult> {
    console.log("üìÑ Converting PDF to images using Cloudinary...");
    const startTime = Date.now();

    try {
      // Convert PDF to high-quality images using Cloudinary
      const images = await cloudinaryService.convertPdfToImages(pdfUrl, {
        quality: 95,
        format: "jpg",
        dpi: 200,
        maxPages: 20, // Limit to prevent excessive processing
      });

      if (images.length === 0) {
        throw new Error("No images were generated from PDF");
      }

      console.log(`üìñ Processing ${images.length} page(s) with OCR...`);
      await this.initializeTesseract();

      let combinedText = "";
      let totalConfidence = 0;
      let wordCount = 0;

      // Process each page image with OCR (with timeout protection)
      let successfulPages = 0;
      for (let i = 0; i < images.length; i++) {
        const image = images[i];
        console.log(`üîç Processing page ${i + 1}/${images.length}...`);

        try {
          // Add 30-second timeout to prevent infinite hanging
          const result = (await Promise.race([
            this.tesseractWorker!.recognize(image.url),
            new Promise((_, reject) =>
              setTimeout(
                () => reject(new Error("OCR timeout after 30 seconds")),
                30000
              )
            ),
          ])) as any;

          const pageText = result.data.text || "";
          const pageConfidence = (result.data.confidence || 0) / 100;

          combinedText += `\n=== PAGE ${i + 1} ===\n${pageText}\n`;
          totalConfidence += pageConfidence;
          wordCount += pageText.split(/\s+/).length;
          successfulPages++;

          console.log(
            `‚úÖ Page ${i + 1}: ${pageText.length} characters, ${(
              pageConfidence * 100
            ).toFixed(1)}% confidence`
          );
        } catch (pageError: any) {
          console.warn(
            `‚ö†Ô∏è Failed to process page ${i + 1}:`,
            pageError.message
          );
          combinedText += `\n=== PAGE ${
            i + 1
          } (PROCESSING FAILED - MANUAL REVIEW REQUIRED) ===\n`;

          // If Tesseract completely fails, we need to clean up and continue
          if (
            pageError.message.includes("timeout") ||
            pageError.message.includes("worker")
          ) {
            console.error(
              "üö® Tesseract worker issue detected - attempting recovery..."
            );
            try {
              if (this.tesseractWorker) {
                await this.tesseractWorker.terminate();
                this.tesseractWorker = null;
              }
            } catch (e) {
              // Ignore cleanup errors
            }
          }
        }
      }

      // Clean up Cloudinary images after processing
      const publicIds = images.map((img) => img.publicId);
      await cloudinaryService.deleteImages(publicIds);
      console.log("üóëÔ∏è Cleaned up temporary images from Cloudinary");

      // Calculate average confidence based on successful pages only
      const averageConfidence =
        successfulPages > 0 ? totalConfidence / successfulPages : 0.1;

      // If no pages processed successfully, add helpful message
      if (successfulPages === 0) {
        combinedText = `
CLOUDINARY PDF CONVERSION: SUCCESS ‚úÖ
TESSERACT OCR PROCESSING: FAILED ‚ùå

The PDF was successfully converted to ${
          images.length
        } image(s), but OCR text extraction failed.

IMMEDIATE ACTIONS REQUIRED:
1. Manual data entry from the converted images
2. System administrator should fix Tesseract configuration  
3. Try uploading PDF pages as individual JPG/PNG files

TECHNICAL NOTES:
- Pages converted: ${images.length}
- Processing time: ${Date.now() - startTime}ms
- Error: OCR worker initialization/processing failed

STATUS: Document marked as FAILED - requires manual intervention
        `.trim();
      } else if (successfulPages < images.length) {
        combinedText += `\n\n=== PROCESSING SUMMARY ===\n`;
        combinedText += `Successfully processed: ${successfulPages}/${images.length} pages\n`;
        combinedText += `Failed pages require manual review and data entry.\n`;
      }

      return {
        text: combinedText.trim(),
        confidence: averageConfidence,
        processingTime: Date.now() - startTime,
        method: "tesseract",
        pageCount: images.length,
        wordCount,
      };
    } catch (error: any) {
      console.error("‚ùå PDF processing with Cloudinary failed:", error);

      // Fallback: provide user guidance
      const fallbackMessage = `
PDF PROCESSING FAILED - Cloudinary Error: ${error.message}

ALTERNATIVE SOLUTIONS:
1. Convert PDF to high-quality images (JPG/PNG) manually and upload
2. Try uploading one page at a time as images
3. Ensure PDF is not password-protected or corrupted
4. Copy-paste key lab values into notes section if needed

This ensures 95%+ accuracy for lab value extraction.
      `.trim();

      throw new Error(fallbackMessage);
    }
  }

  private async classifyDocument(
    text: string,
    filename: string
  ): Promise<{
    documentType: string;
    labSource?: string;
    extractedData?: any;
  }> {
    console.log("üè∑Ô∏è Classifying document type...");

    const lowerText = text.toLowerCase();
    const lowerFilename = filename.toLowerCase();

    // Lab company identification patterns
    const labPatterns = {
      labcorp: [
        "labcorp",
        "laboratory corporation",
        "lab corp",
        "lcdf",
        "labcorp diagnostics",
      ],
      quest: [
        "quest diagnostics",
        "quest labs",
        "questlabs",
        "quest diagnostic",
        "quest lab",
      ],
      "nutri-q": [
        "nutri-q",
        "nutriq",
        "nutritional assessment questionnaire",
        "naq",
        "nutri q",
      ],
      kbmo: [
        "kbmo diagnostics",
        "kbmo",
        "food inflammation test",
        "fit test",
        "kbmo fit",
      ],
      dutch: [
        "dutch test",
        "dried urine",
        "precision analytical",
        "dutch complete",
        "dutch plus",
      ],
      genova: [
        "genova diagnostics",
        "genova",
        "gdx",
        "comprehensive digestive stool analysis",
      ],
      "gi-map": [
        "gi-map",
        "gi map",
        "gastrointestinal microbial",
        "diagnostic solutions",
      ],
      organic_acids: [
        "organic acids test",
        "oat test",
        "great plains",
        "organic acid test",
        "metabolic analysis",
      ],
    };

    // Document type patterns
    const typePatterns = {
      comprehensive_metabolic_panel: [
        "comprehensive metabolic panel",
        "cmp",
        "basic metabolic",
        "glucose",
        "creatinine",
        "bun",
        "sodium",
        "potassium",
      ],
      lipid_panel: [
        "lipid panel",
        "cholesterol",
        "triglycerides",
        "hdl",
        "ldl",
        "lipid profile",
      ],
      thyroid_panel: [
        "thyroid",
        "tsh",
        "free t4",
        "free t3",
        "t3 reverse",
        "thyroid stimulating hormone",
      ],
      cbc_differential: [
        "complete blood count",
        "cbc",
        "differential",
        "white blood cell",
        "hemoglobin",
        "hematocrit",
        "platelet",
      ],
      hormone_panel: [
        "hormone",
        "testosterone",
        "estrogen",
        "progesterone",
        "cortisol",
        "dhea",
        "sex hormone",
      ],
      food_sensitivity: [
        "food sensitivity",
        "food allergy",
        "ige",
        "igg",
        "food panel",
        "allergen",
      ],
      stool_analysis: [
        "stool analysis",
        "stool test",
        "parasitology",
        "digestive",
        "microbiome",
        "gut health",
      ],
      nutrient_analysis: [
        "vitamin",
        "mineral",
        "b12",
        "folate",
        "iron",
        "nutrient",
        "deficiency",
      ],
    };

    // Identify lab source
    let labSource: string | undefined;
    let maxLabMatches = 0;

    for (const [lab, patterns] of Object.entries(labPatterns)) {
      const matches = patterns.filter(
        (pattern) =>
          lowerText.includes(pattern) || lowerFilename.includes(pattern)
      ).length;

      if (matches > maxLabMatches) {
        maxLabMatches = matches;
        labSource = lab;
      }
    }

    // Identify document type
    let documentType = "unknown";
    let maxTypeMatches = 0;

    for (const [type, patterns] of Object.entries(typePatterns)) {
      const matches = patterns.filter((pattern) =>
        lowerText.includes(pattern)
      ).length;

      if (matches > maxTypeMatches) {
        maxTypeMatches = matches;
        documentType = type;
      }
    }

    // Special case: If it's a NutriQ document, classify as such
    if (labSource === "nutri-q") {
      documentType = "nutriq_assessment";
    }

    const confidence = Math.max(maxLabMatches, maxTypeMatches) / 10; // Normalize

    console.log(
      `üè∑Ô∏è Classification result: ${documentType} from ${
        labSource || "unknown"
      } (confidence: ${confidence.toFixed(2)})`
    );

    return {
      documentType,
      labSource,
      extractedData: {
        confidence,
        labMatches: maxLabMatches,
        typeMatches: maxTypeMatches,
        textLength: text.length,
      },
    };
  }

  async cleanup(): Promise<void> {
    if (this.tesseractWorker) {
      await this.tesseractWorker.terminate();
      this.tesseractWorker = null;
      console.log("üßπ Tesseract worker terminated");
    }
  }
}

// Export singleton instance
export const medicalOCRService = new MedicalOCRService();

// Cleanup on process exit
process.on("exit", () => {
  medicalOCRService.cleanup();
});
